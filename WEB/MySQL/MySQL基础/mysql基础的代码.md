mysql :
```
    启动/停止mysql数据库服务：
    	命令行模式（需要管理员身份）：启动/停止：net  start/stop  mysql
        服务模式：控制面板〉管理工具〉服务〉mysql >启动/停止

    登录/退出mysql系统:
        登录：mysql -h服务器地址 -u登录名 【-P端口号】 -p
        退出：quit; 或 exit;————是指已经登录（进入）了mysql之后

    设置mysql 编码：
        set names 编码名
        	cmd客户端中是固定的gbk编码，
        	而php网页中，是该网页文件的编码（现在主流都是utf8）。

    数据库的备份和恢复：
        备份：就是将一个数据库，完整地“转换为”一个可以随时“携带和传送”的文件。
        语法：
            mysqldump  -h服务器地址  -u登录名  -p   数据库名 > 文件名
        恢复： 就是讲一个备份的数据库文件，完整地还原为一个可以使用的数据库。
        语法：
            mysql  -h服务器地址  -u登录名   -p   数据库名 < 文件名（文件位置的/ 复制的时候是反的）
        注意：
            1，这两个命令，都是在“没有登录mysql”的时候使用。
            2，其中mysqldump命令还要求为管理员身份。
            3，通常，恢复，就是指恢复原来数据库中的所有表数据信息及其他信息，而数据库名可以是原来的名字或新的名字。

    注释：
        1， 单行注释：    #注释内容
        2， 多行注释：   /* 注释内容*/

    数据库定义语句
        创建数据库：
            语法： create   database  数据库名   【charset  字符编码名称】   【collate  排序规则】；
        删除数据库：
            语法:  drop  database 【if  exists 】 数据库名；
            说明：if  exists 是用于一种“安全运行”的考虑。如果数据库不存在，也不会报错。否则会报错。
        修改数据库（字符编码)：
            基本上，就是修改数据库的“属性”而已：只有2个：
            修改编码；
            修改排序规则；
            alter  database  数据库名   charset  新的编码名   collate  新的排序规则名
        显示所有数据库：
            show databases；
        显示一个数据库的创建语句：
            语法：show  create  database  数据库名；
        “进入”（选择）某个数据库：
            语法：use  数据库名；

    数据类型：
        时间类型
            datetime类型：   时间日期类型
            date类型：       日期类型
            time类型：       时间类型
            year类型：       年份类型
            timestamp:      时间戳类型：
                就是指一个时间的“数据值”——本质其实一个数字，类似js中的GetTime()，或php中是Time()，他们都得到的是一个“整数数字”。
                它的一个重要作用是：他会自动获得时间戳的数据值——相当于“now()”。

        字符串类型：
            varchar类型：变长字符串，此类型的实际长度最多是255个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。
            char类型：定长字符串；使用时通常需要设定其长度，如果不设定，默认是1.最大理论长度是255个。
            enum类型：单选项字符串数据类型。它非常适合于存储表单界面中的“单选项值”；
            set类型：多选项字符串数据类型。它非常适合于存储表单界面中的“多选项值”；
            text类型：它称为“长文本”字符类型。通常，其中存储的数据不占据表格中的数据容量限制。其本身最长可存储65535个字符。如果存储中文utf8，则最多是65533/3个；

        数值类型：
            呜呜呜~~~~

    创建表
        基本语法形式：
        	create table 【if not exists】 表名 (字段列表 【，索引或约束列表】) 【表选项列表】；
        	或：
        	create table 【if not exists】 表名 (字段1， 字段2， ....  【，索引1， 索引2， ....，约束1，约束2，....  】) 【表选项1,  表选项2，.... 】

        数据表的字段：
            字段设定形式：
                字段名   类型   【字段属性1  字段属性2  .....】
            说明：
                字段属性可以有多个（根据具体的需要），相互之间直接空格隔开；主要如下几个：
                    auto_increment：只用于整数类型，让该字段的值自动获得一个增长值。通常用于做一个表的第一个字段的设定，并且通常还当做主键（primary key）；
                    primary  key： 用于设定该字段为主键，此时该字段的值就可以“唯一确定”一行数据；
                    unique  key：  设定该字段是“唯一的”，也就是不重复的。
                    not  null：用于设定该字段不能为空（null），如果没有设定，则默认是可为空的。
                    default  XX值：	用于谁定该字段的默认值，此时如果insert没有给值的时候就使用该默认值
                    comment  ‘字段说明文字’：

        索引:什么是索引？
            索引是系统内部自动维护的隐藏的“数据表”，它的作用是，可以极大地加快数据的查找速度！
            这个隐藏的数据表，其中的数据是自动排好序的，其查找速度就是建立在这个基础上。
            通常，所谓建立索引，其实是指定一个表的某个或某些字段作为“索引数据字段”就可以了，形式为：
            索引类型有如下几个：
                普通索引：  语法： key（字段名）
                    含义：  就是一个索引而已，没有其他作用，只能加快查找速度；
                唯一索引：  语法： unique  key（字段名）
                    含义：  是一个索引，而且还可以设定其字段的值不能重复（唯一性）；
                主键索引：  语法： primary  key（字段名）
                    含义：  是一个索引，而且，还具有区分该表中的任何一行数据的作用（其实也是唯一性）
                        它其实比唯一性索引多一点功能：唯一性可以为空null，而主键不能为空；
                全文索引：  语法： fulltext （字段名）。
                外键索引：  语法： foreign  key （字段名） references  其他表名(对应其他表中的字段名)；
                    含义： 外键，就是指，设定的某个表（tab1）某个字段（f1），它的数据的值，必须是在另一个表（tab2）中的某个字段（f2）中存在！

        约束:什么叫做约束？
            约束，就是要求数据需要满足什么条件的一种“规定”。
            主要有如下几种约束：
                主键约束：形式： primary key ( 字段名);
                    含义（作用）：使该设定字段的值可以用于“唯一确定一行数据”，其实就是“主键”的意思。
                唯一约束：形式： unique   key ( 字段名);
                    含义（作用）：使该设定字段的值具有“唯一性”，自然也是可区分的。
                外键约束：形式： foreign key ( 字段名)  references  其他表名(对应其他表中的字段名) ;
                    含义（作用）：使该设定字段的值，必须在其谁定的对应表中的对应字段中已经有该值了。
                非空约束： 形式： not  null，其实就是设定一个字段时写的那个“not null”属性。
                    这个约束只能写在字段属性上；
                默认约束： 形式： default  XX值；其实就是设定一个字段时写的那个“default  默认值”属性
                    这个约束只能写在字段属性上；
                检查约束： 形式： check（某种判断语句），比如：
                    create  table  tab1 (
                        age  tinyint,
                        check  (age>=0 and age <100)	/*这就是检查约束*/ 
                    )
            其实，主键约束，唯一约束，外键约束，只是“同一件事情的2个不同角度的说法”，他们同时也称为“主键索引”，“唯一索引”，“外键索引”。

        表选项列表就是:创建一个表的时候，对该表的整体设定，主要有如下几个：
            charset = 要使用的字符编码，  SET NAMES 'utf8';   这个也是修改字符集
            engine = 要使用的存储引擎（也叫表类型），默认是InnoDB。
            auto_increment = 设定当前表的自增长字段的初始值，默认是1
            comment = ‘该表的一些说明文字’

    修改表: 是指修改表的结构——正如创建表也是设定表的结构。创建表能做的事，修改表几乎都能做——但很不推荐去修改表，而是应该在创建表的时候就基本确定表的结构。
        大体来说，有：1对字段进行：添加，删除，修改； 2对索引进行：添加，删除
        常见几个：
        	添加字段：alter  table 表名 add  [column] 新字段名 字段类型  [字段属性列表]；
        	修改字段（并可改名）：alter  table 表名 change [column] 旧字段名 新字段名 新字段类型 [新字段属性列表]；
        	删除字段：alter  table  表名 drop  [column] 字段名；

        	添加普通索引：alter  table 表名 add  key  [索引名]  (字段名1[，字段名2,...])；
        	添加唯一索引(约束)：alter table 表名 add unique key (字段名1[，字段名2,...])；
        	添加主键索引(约束)：alter table 表名 add primary key (字段名1[，字段名2,...])；

        	修改表名：alter  table  旧表名   rename  [to] 新表名；
            删除表 : drop  table  【if  exists】 表名；

    其他表的相关语句：
    	显示当前数据库中的所有表: show tables；
    	显示某表的结构: desc 表名； 或：describe 表名；
    	显示某表的创建语句：show create table 表名；
    	重命名表：rename table 旧表名 to 新表名；
    	从已有表复制表结构：create table [if not exists] 新表名 like 原表名;

    数据库（表）设计3范式：
        第一范式（1NF）：原子性，数据不可再分：一个表中的数据（字段值）不可再分。    
        第二范式（2NF）：唯一性，消除部分依赖：一个表中的每一行必须唯一可区分，且非主键字段值完全依赖主键字段值。    
            经验上：常常是每个表都要设计主键，并通常多数情况下，使用一个自增长的int类型的字段当做主键
            实际，有2个方面的要求：
                1，每一行数据具有唯一性：只要给表设计主键，就可以保证唯一性。
                2，消除数据之间的“部分依赖”；
        第三范式（3NF）：独立性，消除传递依赖：使一个表中的任何一个非主键，完全独立地依赖于主键，而不能又依赖于另外的非主键。

        什么叫做部分依赖？
            如果某个字段，只依赖于“部分主键字段”，此时就称为“部分依赖”
            ——发生此情况的前提一定是：主键字段有多个！！！
        什么叫做完全依赖：
            就是某个字段，是依赖于“主键的所有字段”。
            ——推论：如果一个表的主键只有一个字段，则此时必然是完全依赖。
        经验总结：
            通常，在设计表的时候，基本只要遵循这样一个原则，就可以满足前述3范式要求： 每一种数据，使用一个表来存储。


    数据操作语言：
        插入数据（增）：
            形式1：insert into  表名 （字段名1，字段名2，....） values (值表达式1，值表达式2，....), (.....), ....;
                插入数据，可以多条
        	形式2：replace into 表名 [（字段名1，字段名2，....）] values (值表达式1，值表达式2，....), (.....), ....;
                插入数据，如果插入的数据的主键或唯一键“有重复”，则此时就会变成“修改该行数据”；
        	形式3：insert into 表名 （字段名1，字段名2，....） select 字段名1，字段名2，.... from 其他表名；
                插入查询到的数据，字段名和类型必须对应

            load  data（载入数据）语法： 它适用于载入“结构整齐的纯文本数据”：
                当然，前提是，有一个这样的对应结构的现有的表：
                载入语法形式：
                    load  data  infile  “完整的数据文件的路径”  into  table  表名；
        
        删除数据表（删）：
            语法：delete  from  表名  【where 条件】 【order by排序字段】 【limit 限定行数】；
        修改数据（改）：
            语法：update  表名  set  字段1=值1，字段2=值2，...... 【where 条件】 【order by排序字段】 【limit 限定行数】；

    基本查询 : select  [all | distinct]  字段或表达式列表  [from子句]  [where子句]  [group by子句]   [having子句]   [order by子句]   [limit子句]；
        all 和 distinct ： 用于设定select出来的数据，是否消除“重复行”，可以不写，那就是默认值all：
            all：表示不消除，即所有都出来，默认值；
            distinct：表示会消除；
        from子句 : from子句表示select部分从中“取得”数据的数据源——其实就是表。
        where子句: where子句就是对from子句中的“数据源”中的数据进行筛选的条件设定,
            where子句中,通常都需要使用各种“运算符”；
                算术运算符：  +  -   *   /   %
                比较运算符：  >   >=   <    <=   =（等于）    < >（不等于）   ==(等于)  !=(不等于)
                逻辑运算符：  and   or    not  
            is运算符：空值和布尔值的判断
                有4种情况的使用：
                    XX  is  null：判断某个字段是“null”值——就是没有值；
                    XX  is  not  null：判断某个字段不是“null”值
                    XX  is  true：判断某个字段为“真”（true）
                    XX  is  false：判断某个字段为“假”（false）：0， 0.0,  ‘’,  null 
            between运算符：范围判断
                用于判断某个字段的数据值是否在某个给定的范围——适用于数字类型；
                语法：XX  between  值1  and  值2；表示“值1”和“值2”之间值，
            in运算符：取出指定的那条
                语法：XX  in  (值1，值2， 值3， .....);
            like运算符：对字符串的某种特征信息的模糊查找。它其实依赖于以下2个特殊的“符号”：
                语法：XX  like  ‘要查找的内容’
                    %		：它代表“任何个数的任何字符”；
                    _		：（下杠），它代表“一个任何字符”；
        group by 分组子句：  group  by  字段1 【desc|asc】， 字段2 【desc|asc】， .....;
            举例：select pinpai, count(*) as 数量, max(jiaqian) as 最高价, min(jiaqian) as 最低价, avg(jiaqian) as 平均价, sum(jiaqian) as 总价 from 表名 group by pinpai;
            应用中，分组之后，通常只有如下几种可用的“组信息”了（即可以出现在select中）：
                1，分组依据本身的信息，其实就是该分组依据的字段名；
                2，每一组的“数量”信息：就是用count（*）获得；
                3，原来数据中的“数值类型字段的聚合信息”，包括如下几个：
                最大值：  max(字段名)
                最小值：  min(字段名)
                平均值：  avg(字段名)
                总和值：  sum(字段名)
                上述其实是4个系统内部函数；
        having子句 ：having的作用跟where完全一样，但其只是对“分组的结果数据”进行筛选；
            where对原始数据行进行筛选；
            having对分组之后的数据行进行筛选；
        order by 子句 : order by  字段1  【asc|desc】， 字段2  【asc|desc】，......;
            排序可以设定正序（asc，默认值）或倒序（desc）；
        limit子句 ：它用于将“前述取得的数据”，按指定的行取出来：从第几行开始取出多少行；
            语法：limit  起始行号， 要取出的几行数据；
        对整个select语句的一些总结：
            1，虽然在形式上，select的很多子句都是可以省略的，但他们的顺序（如果出现），就不能打乱的：必须仍然按照给出的顺序写出；
            2，where子句依赖于from子句：即没有from，就不能有where；
            3，having子句依赖于group by子句：即没有group by，就不能有having；
            4，select中的“字段”也是依赖于from子句；
            5，基本上也都是按照该顺序进行的：从from的数据源中获得“所有数据”，然后使用where对这些数据进行“筛选”，之后再使用groupby子句对筛选出来的数据进行“分组”，接下来才可以使用having对这些分组的数据进行筛选，然后才可以orderby 和limit。

    连接查询：就是将两个或两个以上的表，“连接起来”，当做一个数据源，并从中去取得所需要的数据；
        连接基本形式：表1  【连接形式】 join  表2  【on  连接条件】 {【连接形式】 join  表3  【on  连接条件】};
        连接主要分为以下几类：
            交叉连接 cross  join：其实就是刚才讲连接的基本概念的时候的连接形式（结果）——它没有条件，只是按连接的基本概念，将所有数据行都连接起来的结果。它又叫做“笛卡尔积”；
                对于表1（n1个字段，n2行），表2,（m1个字段，m2行），他们交叉连接的结果是： 有n1+m1个列； 有n2*m2个行；
                语法：select * from  表1  cross  join  表2；
            内连接 inner join： select  *  from  表1  【inner】  join  表2  on  连接条件；
                含义：其中 on 表一.id = 表二.id 被称为“连接条件”，它基本上就是我们之前所学的“外键关系”的一个描述。
            左（外）连接 left (outer) join：表1（左表）  left  【outer】 join  表2（右表）  on  连接条件
                含义：其实就是将两个表的内连接的结果，再加上左边表全部的数据结果；
            右（外）连接 right (outer) join：表1（左表）  right  【outer】 join  表2（右表）  on  连接条件
                含义：其实就是将两个表的内连接的结果，再加上右边表全部的数据结果；
            全（外）连接 full (outer) join：没有形式，因为mysql不支持全连接的语法；
                含义：其实就是将两个表的内连接的结果，再加上左边表的不符合内连接所设定的条件的那些数据的结果，以及再加上右边表的不符合内连接所设定的条件的那些数据的结果；

    联合查询union:将两个具有相同字段数量的查询语句的结果，以“上下堆叠”的方式，合并为一个查询结果。
        一个翻译问题的解释：在mysql的手册中，将连接查询（join）翻译为联合查询；而联合查询（union），没有明确翻译。但：在通常的书籍或文章中，join被翻译为“连接”查询；而union才被翻译为联合查询。
        语法形式：select　语句1 union [all ｜ distinct] select　语句2;  此联合查询语句，默认会“自动消除重复行”，即默认是distinct
        union实现“全外连接”：select  * from  表1  left  join 表2 on  条件 union  [all ｜ distinct]  select  * from  表1  right  join 表2  on  条件

    子查询含义：子查询是为主查询服务的，而，通常，都是子查询获得一定的结果数据之后，才去执行主查询；
        在形式上，可以有如下语法：selelct 字段或表达式或子查询 [as 别名] from 表名或链接结果或子查询 where 字段或表达式或子查询的条件判断;即可以在这几个位置出现子查询（其中having其实也可以，因为它跟where是一样含义）；
        按子查询结果，分为：
        	表子查询 ：一个子查询返回的结果理论上是“多行多列”的时候。此时可以当做一个“表”来使用，通常是放在from后面。
        	行子查询 ：一个子查询返回的结果理论上是“一行多列”的时候。此时可以当做一个“行”来使用，通常放在“行比较语法”中；行比较语法类似这样：where  row(字段1，字段2) = (select 行子查询)
        	列子查询 ：一个子查询返回的结果理论上是“多行一列”的时候。此时可以当做“多个值”使用，类似这种：(5, 17, 8, 22)。
        	标量子查询：一个子查询返回的结果理论上是“一行一列”的时候。此时可以当做“一个单个值”使用，类似这种：select 5 as c1; 或select ...where a = 17，或select ... where b > 8;即上述“单个数据值”，可以用标量子查询来代替；
        子查询，按位置（场合）分：
        	作为主查询的结果数据：select c1,(select f1 from tab2) as f11 from tab1; #这里子查询应该只有一个数据（一行一列，标量子查询）
        	作为主查询的条件数据：select c1 from tab1 where c1 in (select f1 from tab2); #这里子查询可以是多个数据（多行一列，列子查询）
        	作为主查询的来源数据：select c1 from (select f1 as c1, f2 from tab2) as t2; #这里子查询可以是任意查询结果（表子查询）。
        常见子查询:
            比较运算符中的子查询语法：操作数 比较运算符 (标量子查询)；
            in的子查询:以前用的in的用法：XX  in  (值1，值2，值3，....); 则in子查询为：XX  in  (列子查询)
            any的子查询语法：操作数 比较运算符 any  (列子查询);
                含义：当某个操作数（字段） 对于该列子查询的其中任意一个值，满足该比较运算符，则就算是满足了条件；即：只要有一个值满足，就算是满足；
            all的子查询：语法：操作数  比较运算符 all   (列子查询)；
                含义：当某个操作数（字段） 对于该列子查询的所有数据值，都满足该比较运算符，才算满足了条件；即：要求全部都满足，才算是满足；
            some的子查询：some是any的同义词。
            exists的查询：语法：where  exists( 子查询 )
                含义：该子查询如果“有数据”，则exists的结果是true，否则就是false
    
    数据库导入:
    先选中数据库，在执行source命令就可以导入数据了
    mysql>use 数据库
    然后使用source命令，后面参数为脚本文件(如这里用到的.sql)
    mysql>source d:/dbname.sql

    用户：
        创建用户：create  user  ‘用户名’@’允许登录的地址/服务器’  identified  by  ‘密码’；
        说明：
            1，允许登录的地址/服务器就是，允许该设定的位置，来使用该设定的用户名和密码登录，其他位置不行；
            2，可见，mysql的安全身份验证，需要3个信息。
        删除用户：drop  user  ‘用户名’@’允许登录的地址或服务器名’;
        修改用户密码：
            修改自己的密码：  set password = password('密码')；
            修改他人的密码（前提是有权限）：  set password  for  '用户名'@'允许登录的地址' = password('密码')；

    清空数据并重置主键:
    truncate table table_name; 

```